**1、什么是 Redis？简述它的优缺点？**
Redis 是一个 Key-Value 类型的内存数据库，
整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush 到硬盘,每秒可以处理超过 10 万次读写操作,单个 value 的最大限制是 1GB

**2、Redis 与 memcached 相比有哪些优势？**
1.redis支持更为丰富的数据类型,memcached 均是简单的字符串
2.redis 的速度比 memcached 快很多 redis 的速度比 memcached 快很多
3.redis 可以持久化其数据 redis 可以持久化其数据

**3、Redis 支持哪几种数据类型？**
String、List、Set、Sorted Set、hashes

**4、Redis 主要消耗什么物理资源？**内存。

**5、Redis 有哪几种数据淘汰策略？**
1.noeviction:尝试执行会让更多内存被使用的命令。
2.allkeys-lru: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。
3.volatile-lru: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键
4.allkeys-random: 回收随机的键使得新添加的数据有空间存放。
5.volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。
6.volatile-ttl: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键

**6、Redis 官方为什么不提供 Windows 版本？**会带来兼容性等问题。

**7、一个字符串类型的值能存储最大容量是多少？**512M

**8、为什么 Redis 需要把所有数据放到内存中？**磁盘 I/O 速度为严重影响 redis 的性能。

**9、Redis 集群方案应该怎么做？都有哪些方案？**
1.codis 2.redis cluster3.0 自带的集群
3.在业务代码层对 key 进行 hash 计算

**10、Redis 集群方案什么情况下会导致整个集群不可用？**
三个节点的集群,在没有复制模型的情况下,如果节点 B 失败了，那么整个集群就会以为缺少5501-11000 这个范围的槽而不可用。

11、MySQL 里有 2000w 数据，redis 中只存 20w 的数据，**如何保证 redis 中的数据都是热点数据？**
限定 Redis 占用的内存，Redis 会根据自身数据淘汰策略，留下热数据到内存

**12、Redis 有哪些适合的场景？**
（1）会话缓存（Session Cache）（2）全页缓存（FPC）（3）队列（4）排行榜/计数器（5）发布/订阅

**13、Redis 支持的 Java 客户端都有哪些？官方推荐用哪个？**
Redisson、Jedis、lettuce 等等，官方推荐使用 Redisson。

**14、Redis 和 Redisson 有什么关系？**
Redisson 是一个高级的分布式协调 Redis 客服端

**15、Jedis 与 Redisson 对比有什么优缺点？**
Jedis 是 Redis 的 Java 实现的客户端，其 API 提供了比较全面的 Redis命令的支持；
Redisson 实现了分布式和可扩展的 Java 数据结构

**16、说说 Redis 哈希槽的概念？**
Redis 集群没有使用一致性 hash,而是引入了哈希槽的概念，Redis 集群有 16384 个哈希槽，每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽，集群的每个节点负责一部分 hash 槽。

**17、Redis 集群的主从复制模型是怎样的？**
为了使在部分节点失败情况下集群仍然可用，所以集群使用了主从复制模型,每个节点都会有 N-1 个复制品.

**18、Redis 集群会有写操作丢失吗？为什么？**
Redis 不能保证数据的强一致性，在特定的条件下可能会丢失写操作。
**19、Redis 集群之间是如何复制的？**异步复制
**20、Redis 集群最大节点个数是多少？**16384 个
**21、Redis 集群如何选择数据库？**默认在 0 数据库。
**22、Redis 中的管道有什么用？**
一次请求/响应服务器能实现处理新的请求,可以将多个命令发送到服务器，而不用等待回复

**23、怎么理解 Redis 事务？**
事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行，不会被其他请求所打断。
事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。

**24、Redis 事务相关的命令有哪几个？**MULTI、EXEC、DISCARD、WATCH

**25、Redis key 的过期时间和永久有效分别怎么设置？**EXPIRE 和 PERSIST 命令

**26、Redis 如何做内存优化？**
尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小

**27、Redis 回收进程如何工作的？**
Redis 检查内存使用情况，如果大于 maxmemory 的限制,则根据设定好的策略进行回收。

**28.加锁机制**
如果你要加锁的那个锁 key 存在的话，你就进行加锁。如何加锁呢？很简单，用下面的命令：hset myLock
接着会执行“pexpire myLock 30000”命令，设置 myLock 这个锁 key 的生存时间

**29.锁互斥机制**
客户端 2 会获取到这个锁 key的剩余生存时间。比如还剩 15000 毫秒的生存时间。此时客户端 2 会进入一个 while 循环，不停的尝试加锁。

Redis 是什么？两句话做一下概括。
是一个完全开源免费的 key-value 内存数据库 2. 通常被认为是一个数据结构服务
器，主要是因为其有着丰富的数据结构 strings、map、 list、sets、 sorted sets。
Redis 使用最佳方式是全部数据 in-memory。
Redis 更多场景是作为 Memcached 的替代者来使用。
当需要除 key/value 之外的更多数据类型支持时，使用 Redis 更合适。
当存储的数据不能被剔除时，使用 Redis 更合适。
Redis（管道，哈希）。
Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，
hash 等数据结构的存储。
Redis 支持数据的备份，即 master-slave 模式的数据备份。
Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可
以再次加载进行使用。
Redis 实现原理或机制。
Redis 是一个 key-value 存储系统。和 Memcached 类似，但是解决了断电后数据
完全丢失的情况，而且她支持更多无化的 value 类型，除了和 string 外，还支持
lists（链表）、sets（集合）和 zsets（有序集合）几种数据类型。这些数据类型都支
持 push/pop、add/remove 及取交集并集和差集及更丰富的操作，而且这些操作都
是原子性的。
Redis 是一种基于客户端 - 服务端模型以及请求 / 响应协议的 TCP 服务。这意味
着通常情况下一个请求会遵循以下步骤：
客户端向服务端发送一个查询请求，并监听 Socket 返回，通常是以阻塞模式，等待
服务端响应。服务端处理命令，并将结果返回给客户端。
在服务端未响应时，客户端可以继续向服务端发送请求，并最终一次性读取所有服务
端的响应。
Redis 管道技术最显著的优势是提高了 Redis 服务的性能。
分区是分割数据到多个 Redis 实例的处理过程，因此每个实例只保存 key 的一个子
集。
通过利用多台计算机内存的和值，允许我们构造更大的数据库。
通过多核和多台计算机，允许我们扩展计算能力；通过多台计算机和网络适配器，允
许我们扩展网络带宽。
Redis 的一些特性在分区方面表现的不是很好：
涉及多个 key 的操作通常是不被支持的。举例来说，当两个 set 映射到不同的
Redis 实例上时，你就不能对这两个 set 执行交集操作。
涉及多个 key 的 Redis 事务不能使用。
当使用分区时，数据处理较为复杂，比如你需要处理多个 rdb/aof 文件，并且从多个
实例和主机备份持久化文件。
增加或删除容量也比较复杂。Redis 集群大多数支持在运行时增加、删除节点的透明
数据平衡的能力，但是类似于客户端分区、代理等其他系统则不支持这项特性。然
而，一种叫做 presharding 的技术对此是有帮助的。
Redis 有两种类型分区。
最简单的分区方式是按范围分区，就是映射一定范围的对象到特定的 Redis 实例。
比如，ID 从 0 到 10000 的用户会保存到实例 R0，ID 从 10001 到 20000 的用
户会保存到 R1，以此类推。
这种方式是可行的，并且在实际中使用，不足就是要有一个区间范围到实例的映射
表。这个表要被管理，同时还需要各 种对象的映射表，通常对 Redis 来说并非是好
的方法。
哈希分区：另外一种分区方法是 hash 分区。这对任何 key 都适用，也无需是
object_name: 这种形式，像下面描述的一样简单：
用一个 hash 函数将 key 转换为一个数字，比如使用 crc32 hash 函数。对 key
foobar 执行 crc32(foobar) 会输出类似 93024922 的整数。
对这个整数取模，将其转化为 0-3 之间的数字，就可以将这个整数映射到 4 个
Redis 实例中的一个了。93024922 % 4 = 2，就是说 key foobar 应该被存到 R2
实例中。注意：取模操作是取除的余数，通常在多种编程语言中用 % 操作符实现。
实际上，上面的集群模式还存在两个问题：

1. 扩容问题：
因为使用了一致性哈稀进行分片，那么不同的 key 分布到不同的 Redis-
Server 上，当我们需要扩容时，需要增加机器到分片列表中，这时候会使得
同样的 key 算出来落到跟原来不同的机器上，这样如果要取某一个值，会出
现取不到的情况，对于这种情况，Redis 的作者提出了一种名为 Pre-
Sharding 的方式：
Pre-Sharding 方法是将每一个台物理机上，运行多个不同断口的 Redis 实
例，假如有三个物理机，每个物理机运行三个 Redis 实际，那么我们的分片
列表中实际有 9 个 Redis 实例，当我们需要扩容时，增加一台物理机，步骤
如下：
1. 在新的物理机上运行 Redis-Server；
2. 该 Redis-Server 从属于 (slaveof) 分片列表中的某一 Redis-Server
（假设叫 RedisA）；
3. 等主从复制 (Replication) 完成后，将客户端分片列表中 RedisA 的
IP 和端口改为新物理机上 Redis-Server 的 IP 和端口；
4. 停止 RedisA。
这样相当于将某一 Redis-Server 转移到了一台新机器上。Prd-Sharding 实
际上是一种在线扩容的办法，但还是很依赖 Redis 本身的复制功能的，如果
主库快照数据文件过大，这个复制的过程也会很久，同时会给主库带来压力。
所以做这个拆分的过程最好选择为业务访问低峰时段进行。
2. 单点故障问题：
还是用到 Redis 主从复制的功能，两台物理主机上分别都运行有 Redis-
Server，其中一个 Redis-Server 是另一个的从库，采用双机热备技术，客户
端通过虚拟 IP 访问主库的物理 IP，当主库宕机时，切换到从库的物理 IP。
只是事后修复主库时，应该将之前的从库改为主库（使用命令 slaveof no
one），主库变为其从库（使命令 slaveof IP PORT），这样才能保证修复期
间新增数据的一致性。
什么是 MongoDB。
非关系型数据库 (NoSql),Mongo DB 很好的实现了面向对象的思想 (OO 思想), 在
Mongo DB 中 每一条记录都是一个 Document 对象。Mongo DB 最大的优势在
于所有的数据持久操作都无需开发人员手动编写 SQL 语句, 直接调用方法就可以轻松
的实现 CRUD 操作.
MongoDB 特点。
高性能、易部署、易使用，存储数据非常方便。主要功能特性有：
面向集合存储，易存储对象类型的数据。
模式自由。
支持动态查询。
支持完全索引，包含内部对象。
支持查询。
支持复制和故障恢复。
使用高效的二进制数据存储，包括大型对象（如视频等）。
自动处理碎片，以支持云计算层次的扩展性
支持 Python，PHP，Ruby，Java，C，C#，Javascript，Perl 及 C++ 语言的驱动
程序，社区中也提供了对 Erlang 及. NET 等平台的驱动程序。
文件存储格式为 BSON（一种 JSON 的扩展）。
可通过网络访问。
MongoDB 的功能。
面向集合的存储：适合存储对象及 JSON 形式的数据。
动态查询：Mongo 支持丰富的查询表达式。查询指令使用 JSON 形式的标记，可轻
易查询文档中内嵌的对象及数组。
完整的索引支持：包括文档内嵌对象及数组。Mongo 的查询优化器会分析查询表达
式，并生成一个高效的查询计划。
查询监视：Mongo 包含一个监视工具用于分析数据库操作的性能。
复制及自动故障转移：Mongo 数据库支持服务器之间的数据复制，支持主 - 从模式
及服务器之间的相互复制。复制的主要目标是提供冗余及自动故障转移。
高效的传统存储方式：支持二进制数据及大型对象（如照片或图片）
自动分片以支持云级别的伸缩性：自动分片功能支持水平的数据库集群，可动态添加
额外的机器。
MongoDB 的适用场景。
网站数据：Mongo 非常适合实时的插入，更新与查询，并具备网站实时数据存储所
需的复制及高度伸缩性。
缓存：由于性能很高，Mongo 也适合作为信息基础设施的缓存层。在系统重启之
后，由 Mongo 搭建的持久化缓存层可以避免下层的数据源 过载。
大尺寸，低价值的数据：使用传统的关系型数据库存储一些数据时可能会比较昂贵，
在此之前，很多时候程序员往往会选择传统的文件进行存储。
高伸缩性的场景：Mongo 非常适合由数十或数百台服务器组成的数据库。Mongo
的路线图中已经包含对 MapReduce 引擎的内置支持。
用于对象及 JSON 数据的存储：Mongo 的 BSON 数据格式非常适合文档化格式的
存储及查询。
Redis、memcache、MongoDB 对比。
mongodb 和 memcached 不是一个范畴内的东西。mongodb 是文档型的非关系
型数据库，其优势在于查询功能比较强大，能存储海量数据。
和 memcached 更为接近的是 Redis。它们都是内存型数据库，数据保存在内存
中，通过 tcp 直接存取，优势是速度快，并发高，缺点是数据类型有限，查询功能不
强，一般用作缓存。
1. 性能
Redis 和 memcache 差不多，要大于 mongodb。
2. 操作的便利性
memcache 数据结构单一。
Redis 丰富一些，数据操作方面，Redis 更好一些，较少的网络 IO 次数。
mongodb 支持丰富的数据表达，索引，最类似关系型数据库，支持的查询语
言非常丰富。
3. 内存空间的大小和数据量的大小
Redis 在 2.0 版本后增加了自己的 VM 特性，突破物理内存的限制；可以对
key value 设置过期时间（类似 memcache）。
memcache 可以修改最大可用内存, 采用 LRU 算法。
mongoDB 适合大数据量的存储，依赖操作系统 VM 做内存管理，吃内存也
比较厉害，服务不要和别的服务在一起。
4. 可用性（单点问题）
Redis 对于单点问题，依赖客户端来实现分布式读写；主从复制时，每次从节
点重新连接主节点都要依赖整个快照, 无增量复制，因性能和效率问题，所以
单点问题比较复杂；不支持自动 sharding, 需要依赖程序设定一致 hash 机
制。一种替代方案是，不用 Redis 本身的复制机制，采用自己做主动复制
（多份存储），或者改成增量复制的方式（需要自己实现），一致性问题和性
能的权衡。
Memcache 本身没有数据冗余机制，也没必要；对于故障预防，采用依赖成
熟的 hash 或者环状的算法，解决单点故障引起的抖动问题。
mongoDB 支持 master-slave,replicaset（内部采用 paxos 选举算法，自
动故障恢复）,auto sharding 机制，对客户端屏蔽了故障转移和切分机制。
5. 可靠性（持久化）
对于数据持久化和数据恢复，Redis 支持（快照、AOF）：依赖快照进行持久
化，aof 增强了可靠性的同时，对性能有所影响。
memcache 不支持，通常用在做缓存, 提升性能；
MongoDB 从 1.8 版本开始采用 binlog 方式支持持久化的可靠性。
6. 数据一致性（事务支持）
Memcache 在并发场景下，用 cas 保证一致性。
Redis 事务支持比较弱，只能保证事务中的每个操作连续执行。
mongoDB 不支持事务。
7. 数据分析
mongoDB 内置了数据分析的功能 (mapreduce), 其他不支持。
8. 应用场景
Redis：数据量较小的更性能操作和运算上。
memcache：用于在动态系统中减少数据库负载，提升性能; 做缓存，提高性
能（适合读多写少，对于数据量比较大，可以采用 sharding）。
MongoDB: 主要解决海量数据的访问效率问题。
Redis 有什么用？只有了解了它有哪些特性，我们在用的时候才能扬长避短，为我们所用。
1. 速度快：使用标准 C 写，所有数据都在内存中完成，读写速度分别达到 10
万 / 20 万。
2. 持久化：对数据的更新采用 Copy-on-write 技术，可以异步地保存到磁盘
上，主要有两种策略，一是根据时间，更新次数的快照（save 300 10 ）二是
基于语句追加方式 (Append-only file，aof) 。
3. 自动操作：对不同数据类型的操作都是自动的，很安全。
4. 快速的主 -- 从复制，官方提供了一个数据，Slave 在 21 秒即完成了对
Amazon 网站 10G key set 的复制。
5. Sharding 技术： 很容易将数据分布到多个 Redis 实例中，数据库的扩展是
个永恒的话题，在关系型数据库中，主要是以添加硬件、以分区为主要技术形
式的纵向扩展解决了很多的应用场景，但随着 web2.0、移动互联网、云计算
等应用的兴起，这种扩展模式已经不太适合了，所以近年来，像采用主从配
置、数据库复制形式的，Sharding 这种技术把负载分布到多个特理节点上去
的横向扩展方式用处越来越多。
这里对 Redis 数据库做下小结。
1. 提高了 DB 的可扩展性，只需要将新加的数据放到新加的服务器上就可以了
2. 提高了 DB 的可用性，只影响到需要访问的 shard 服务器上的数据的用户
3. 提高了 DB 的可维护性，对系统的升级和配置可以按 shard 一个个来搞，对
服务产生的影响较小
4. 小的数据库存的查询压力小，查询更快，性能更好