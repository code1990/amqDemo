**1、什么是 Redis？简述它的优缺点？**
Redis 是一个 Key-Value 类型的内存数据库，
整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush 到硬盘,每秒可以处理超过 10 万次读写操作,单个 value 的最大限制是 1GB

**2、Redis 与 memcached 相比有哪些优势？**
1.redis支持更为丰富的数据类型,memcached 可缓存图片和视频
2.redis 的速度比 memcached 快很多 redis 的速度比 memcached 快很多
3.redis 可以持久化其数据 redis 可以持久化其数据

**3、Redis 支持哪几种数据类型？**
String、List、Set、Sorted Set、hashes

**4、Redis 主要消耗什么物理资源？**内存。

**5、Redis 有哪几种数据淘汰策略？**
1.noeviction:尝试执行会让更多内存被使用的命令。
2.allkeys-lru: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。
3.volatile-lru: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键
4.allkeys-random: 回收随机的键使得新添加的数据有空间存放。
5.volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。
6.volatile-ttl: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键

**6、Redis 官方为什么不提供 Windows 版本？**会带来兼容性等问题。

**7、一个字符串类型的值能存储最大容量是多少？**512M

**8、为什么 Redis 需要把所有数据放到内存中？**磁盘 I/O 速度为严重影响 redis 的性能。

**9、Redis 集群方案应该怎么做？都有哪些方案？**
1.codis 2.redis cluster3.0 自带的集群
3.在业务代码层对 key 进行 hash 计算

**10、Redis 集群方案什么情况下会导致整个集群不可用？**
三个节点的集群,在没有复制模型的情况下,如果节点 B 失败了，那么整个集群就会以为缺少5501-11000 这个范围的槽而不可用。

11、MySQL 里有 2000w 数据，redis 中只存 20w 的数据，**如何保证 redis 中的数据都是热点数据？**
限定 Redis 占用的内存，Redis 会根据自身数据淘汰策略，留下热数据到内存

**12、Redis 有哪些适合的场景？**
（1）会话缓存（Session Cache）（2）全页缓存（FPC）（3）队列（4）排行榜/计数器（5）发布/订阅

**13、Redis 支持的 Java 客户端都有哪些？官方推荐用哪个？**
Redisson、Jedis、lettuce 等等，官方推荐使用 Redisson。

**14、Redis 和 Redisson 有什么关系？**
Redisson 是一个高级的分布式协调 Redis 客服端

**15、Jedis 与 Redisson 对比有什么优缺点？**
Jedis 是 Redis 的 Java 实现的客户端，其 API 提供了比较全面的 Redis命令的支持；
Redisson 实现了分布式和可扩展的 Java 数据结构

**16、说说 Redis 哈希槽的概念？**
Redis 集群没有使用一致性 hash,而是引入了哈希槽的概念，Redis 集群有 16384 个哈希槽，每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽，集群的每个节点负责一部分 hash 槽。

**17、Redis 集群的主从复制模型是怎样的？**
为了使在部分节点失败情况下集群仍然可用，所以集群使用了主从复制模型,每个节点都会有 N-1 个复制品.

**18、Redis 集群会有写操作丢失吗？为什么？**
Redis 不能保证数据的强一致性，在特定的条件下可能会丢失写操作。
**19、Redis 集群之间是如何复制的？**异步复制
**20、Redis 集群最大节点个数是多少？**16384 个
**21、Redis 集群如何选择数据库？**默认在 0 数据库。
**22、Redis 中的管道有什么用？**
一次请求/响应服务器能实现处理新的请求,可以将多个命令发送到服务器，而不用等待回复

**23、怎么理解 Redis 事务？**
事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行，不会被其他请求所打断。
事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。

**24、Redis 事务相关的命令有哪几个？**MULTI、EXEC、DISCARD、WATCH

**25、Redis key 的过期时间和永久有效分别怎么设置？**EXPIRE 和 PERSIST 命令

**26、Redis 如何做内存优化？**
尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小

**27、Redis 回收进程如何工作的？**
Redis 检查内存使用情况，如果大于 maxmemory 的限制,则根据设定好的策略进行回收。

**28.加锁机制**
如果你要加锁的那个锁 key 存在的话，你就进行加锁。如何加锁呢？很简单，用下面的命令：hset myLock
接着会执行“pexpire myLock 30000”命令，设置 myLock 这个锁 key 的生存时间

**29.锁互斥机制**
客户端 2 会获取到这个锁 key的剩余生存时间。比如还剩 15000 毫秒的生存时间。此时客户端 2 会进入一个 while 循环，不停的尝试加锁。

**30.watchdog自动延期机制**
加锁的锁key默认生存时间才30秒
启动一个watchdog看门狗，他是一个后台线程，会每隔10秒检查一下，如果客户端1还持有锁key，那么就会不断的延长锁key的生存时间。

**31.可重入加锁机制**
对客户端1的加锁次数，累加1。

**32.释放锁机制**
如果执行lock.unlock()，就可以释放分布式锁
每次都对myLock数据结构中的那个加锁次数减1。如果发现加锁次数是0了，从redis里删除这个key。

**33.上述Redis分布式锁的缺点**
在redis master宕机的时候，可能导致多个客户端同时完成加锁。

34.使用过Redis分布式锁么，它是怎么实现的？

35.使用过Redis做异步队列么，你是怎么用的？有什么缺点？
使用list结构作为队列，rpush生产消息，lpop消费消息。
当lpop没有消息的时候，要适当sleep一会再重试。

**36.什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？**
缓存穿透
故意查询不存在的key,请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。
如何避免？
1：对查询结果为空的情况也进行缓存，缓存时间设置短一点，
2：对一定不存在的key进行过滤。

缓存雪崩
大量缓存集中在某一个时间段失效，给后端带来很大压力。导致系统崩溃。
如何避免？
1：在缓存失效后，控制写缓存的线程数量。
2：设置二级缓存，A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2
3：不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀

**缓存击穿：缓存在某个时间点过期的时候有大量的并发请求**
解决方案：1.使用互斥锁2.物理不过期，但逻辑过期（后台异步线程去刷新）。

**为什么高并发下有时单线程的redis比多线程的memcached效率要高？**
原因：mc多线程模型引入了缓存一致性和锁，加锁带来了性能损耗。

**redis的持久化吗？底层如何实现的？有什么优点缺点？**
RDB：在不同的时间点将redis的数据生成的快照同步到磁盘，定期更新
AOF: 将redis所执行过的所有指令都记录日志

**redis主从复制如何实现的？redis的集群模式如何实现？redis的key是如何寻址的？**

主节点以类似于mysql的二进制日志方式将语句发送给从节点

**使用redis如何设计分布式锁？**

给上锁的对象设置一个超时时间，没有超时则无法获得锁。

**过期策略:**
定时过期(一key一定时器)，惰性过期：只有使用key时才判断key是否已过期



----------

**redis的缓存场景**

缓存方式：1.文件缓存 2.内存缓存

缓存内容:1.缓存热点数据2.缓存查询耗时的内容

--

# [redis的三种集群方式](https://www.cnblogs.com/runnerjack/p/10269277.html)



redis有三种集群方式：主从复制，哨兵模式和集群。

**1.主从复制**

**主从复制原理：**

- 从服务器连接主服务器，发送SYNC命令； 
- 主服务器接收到SYNC命名后，开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令； 
- 主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令； 
- 从服务器收到快照文件后丢弃所有旧数据，载入收到的快照； 
- 主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令； 
- 从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；（**从服务器初始化完成**）
- 主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令（**从服务器初始化完成后的操作**）

**主从复制优缺点：**

**优点：**

- 支持主从复制，主机会自动将数据同步到从机，可以进行读写分离
- 为了分载Master的读操作压力，Slave服务器可以为客户端提供只读操作的服务，写服务仍然必须由Master来完成
- Slave同样可以接受其它Slaves的连接和同步请求，这样可以有效的分载Master的同步压力。
- Master Server是以非阻塞的方式为Slaves提供服务。所以在Master-Slave同步期间，客户端仍然可以提交查询或修改请求。
- Slave Server同样是以非阻塞的方式完成数据同步。在同步期间，如果有客户端提交查询请求，Redis则返回同步之前的数据

**缺点：**

- Redis不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复。
- 主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。
- Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。

**2.哨兵模式**

当主服务器中断服务后，可以将一个从服务器升级为主服务器，以便继续提供服务，但是这个过程需要人工手动来操作。 为此，Redis 2.8中提供了哨兵工具来实现自动化的系统监控和故障恢复功能。

哨兵的作用就是监控Redis系统的运行状况。它的功能包括以下两个。

​    （1）监控主服务器和从服务器是否正常运行。 
​    （2）主服务器出现故障时自动将从服务器转换为主服务器。

**哨兵的工作方式：**

- 每个Sentinel（哨兵）进程以每秒钟一次的频率向整个集群中的Master主服务器，Slave从服务器以及其他Sentinel（哨兵）进程发送一个 PING 命令。
- 如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被 Sentinel（哨兵）进程标记为主观下线（SDOWN）
- 如果一个Master主服务器被标记为主观下线（SDOWN），则正在监视这个Master主服务器的所有 Sentinel（哨兵）进程要以每秒一次的频率确认Master主服务器的确进入了主观下线状态
- 当有足够数量的 Sentinel（哨兵）进程（大于等于配置文件指定的值）在指定的时间范围内确认Master主服务器进入了主观下线状态（SDOWN）， 则Master主服务器会被标记为客观下线（ODOWN）
- 在一般情况下， 每个 Sentinel（哨兵）进程会以每 10 秒一次的频率向集群中的所有Master主服务器、Slave从服务器发送 INFO 命令。
- 当Master主服务器被 Sentinel（哨兵）进程标记为客观下线（ODOWN）时，Sentinel（哨兵）进程向下线的 Master主服务器的所有 Slave从服务器发送 INFO 命令的频率会从 10 秒一次改为每秒一次。
- 若没有足够数量的 Sentinel（哨兵）进程同意 Master主服务器下线， Master主服务器的客观下线状态就会被移除。若 Master主服务器重新向 Sentinel（哨兵）进程发送 PING 命令返回有效回复，Master主服务器的主观下线状态就会被移除。

 **哨兵模式的优缺点**

**优点：**

- 哨兵模式是基于主从模式的，所有主从的优点，哨兵模式都具有。
- 主从可以自动切换，系统更健壮，可用性更高。

**缺点：**

- Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。

**3.Redis-Cluster集群**

redis的哨兵模式基本已经可以实现高可用，读写分离 ，但是在这种模式下每台redis服务器都存储相同的数据，很浪费内存，所以在redis3.0上加入了cluster模式，实现的redis的分布式存储，也就是说每台redis节点上存储不同的内容。

 Redis-Cluster采用无中心结构,它的特点如下：

- 所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽。
- 节点的fail是通过集群中超过半数的节点检测失效时才生效。
- 客户端与redis节点直连,不需要中间代理层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可。

**工作方式：**

在redis的每一个节点上，都有这么两个东西，一个是插槽（slot），它的的取值范围是：0-16383。还有一个就是cluster，可以理解为是一个集群管理的插件。当我们的存取的key到达的时候，redis会根据crc16的算法得出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，通过这个值，去找到对应的插槽所对应的节点，然后直接自动跳转到这个对应的节点上进行存取操作。

为了保证高可用，redis-cluster集群引入了主从模式，一个主节点对应一个或者多个从节点，当主节点宕机的时候，就会启用从节点。当其它主节点ping一个主节点A时，如果半数以上的主节点与A通信超时，那么认为主节点A宕机了。如果主节点A和它的从节点A1都宕机了，那么该集群就无法再提供服务了。