**对象的四种引用**
强引用 只要引用存在，垃圾回收器永远不会回收
软引用 非必须引用，内存溢出之前进行回收
弱引用 第二次垃圾回收时回收
虚引用 垃圾回收时回收，无法通过引用取到对象值

---

**List 和 Set 的区别**

Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。
List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变

----

**HashSet 是如何保证不重复的**

add ()元素时，判断元素是否存在的依据，不仅要比较hash值，同时还要结合equles 方法比较

---

**HashMap 是线程安全的吗，为什么不是线程安全的**

如果有两个线程A和B，都进行插入数据，刚好这两条不同的数据经过哈希计算后得到的哈希码是一样的,会存在数据覆盖的情况，会导致数据不一致

----

**HashMap 的扩容过程**

如果cap 是2的n次方，则容量为cap ，否则为大于cap 的第一个2的n次方的数。

cap =3， hashMap 的容量为4；
cap =4， hashMap 的容量为4；

---

**HashMap 1.7 与 1.8 的 区别，说明 1.8 做了哪些优化，如何优化的？**

在JDK1.7 及之前的版本中， HashMap 又叫散列链表：基于一个数组以及多个链表的实现，hash值冲突的时候，
就将对应节点以链表的形式存储。

JDK1.8 中，当同一个hash值（ Table 上元素）的链表节点数不小于8时，将不再以单链表的形式存储了，会被
调整成一颗红黑树

---

**final finally finalize**

final可以修饰类、变量、方法

finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。

finalize是一个方法，属于Object类的一个方法，该方法一般由垃圾回收器来调用回收垃圾

----

**Java获取反射的三种方法**
1.通过**new对象**实现反射机制 2.通过**路径**实现反射机制 3.通过**类名**实现反射

----

**Java反射机制**

在运行时动态的获取信息以及动态调用对象的方法的功能称为 Java 的反射机制

----

**Arrays.sort 和 Collections.sort 实现原理 和区别**

事实上Collections.sort方法底层就是调用的array.sort方法，

legacyMergeSort (a)：归并排序 ComparableTimSort.sort() ： Timsort 排序

Timsort 排序是结合了合并排序（merge sort）和插入排序（insertion sort）而得出的排序算法

-----

**LinkedHashMap 的应用** 最近最少使用简单缓存。

----

**Cloneable 接口实现原理**
作用是使一个类的实例能够将自身拷贝到另一个新的实例中

浅拷贝是指拷贝对象时仅仅拷贝对象本身（包括对象中的基本变量），而不拷贝对象包含的引用指向的对象。

深拷贝不仅拷贝对象本身，而且拷贝对象包含的引用指向的所有对象

-----

**异常分类以及处理机制**

Throwable又派生出Error类和Exception类。

Error类以及他的子类的实例，代表了JVM本身的错误。错误不能被程序员通过代码处理

Exception以及他的子类，代表程序运行时发送的各种不期望发生的事件。可以被Java异常处理机制使用

非检查异常（ unckecked exception ）： Error 和 RuntimeException 以及他们的子类。javac 在编译时，
不会提示和发现这样的异常，不要求在程序处理这些异常

检查异常（ checked exception ）：除了Error 和 RuntimeException 的其它异常。javac 强制要求程序员
为这样的异常做预备处理工作

----

**wait 和sleep 的区别**

1、sleep 来自Thread 类，和wait 来自Object 类。
2、最主要是sleep方法没有释放锁，而wait方法释放了锁
3、wait，notify和notifyAll 只能在同步控制方法或者同步控制块里面使用，而sleep 可以在任何地方使用
4、sleep 必须捕获异常，而wait ， notify 和notifyAll 不需要捕获异常

----

**数组在内存中如何分配**

静态初始化：初始化时由程序员显式指定每个数组元素的初始值，由系统决定数组长度，如：

动态初始化：初始化时由程序员显示的指定数组的长度，由系统为数据每个元素分配初始值，如：