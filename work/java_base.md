**1.面向对象和面向过程的区别**
**面向过程****优点：** 性能比面向对象高，**缺点：** 没有面向对象易维护、易复用、易扩展
**面向对象****优点：** 易维护、易复用、易扩展，**缺点：** 性能比面向过程低

----
**2. Java** **语言有哪些特点**

1. 简单易学；2. 面向对象3. 平台无关性4. 可靠性；5. 安全性； 6. 支持多线程7. 支持网络编程8. 编译与解释并存；

----

**3.** **关于** **JVM JDK** **和** **JRE** **最详细通俗的解答**
**JVM**Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。

----

**什么是字节码****?****采用字节码的好处是什么****?**
JVM 可以理解的代码就叫做字节码
Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。

----

**Java** **程序从源代码到运行一般有下面** **3** **步：**
.java--> .class->机器码 这一步。在这一步 jvm 类加载器首先加载字节码文件，然后通过解释器逐行解释执行

----
**JDK** **和** **JRE**
JDK 是 Java Development Kit，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。

JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和一些基础构件。

**4. Oracle JDK** **和** **OpenJDK** **的对比**

1. Oracle JDK 版本将每三年发布一次，而 OpenJDK 版本每三个月发布一次；
2. OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是OpenJDK 的一个实现，并不是完全开源的；
3. Oracle JDK 比 OpenJDK 更稳定。OpenJDK 和 Oracle JDK 的代码几乎相同，但 Oracle JDK 有更多的类和一些错误修复。
4. 顶级公司正在使用 Oracle JDK
5. 在响应性和 JVM 性能方面，Oracle JDK 与 OpenJDK 相比提供了更好的性能；
6. Oracle JDK 不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；
7. Oracle JDK 根据二进制代码许可协议获得许可，而 OpenJDK 根据 GPLv2 许可获得许可。
**5. Java** **和** **C++****的区别**
都是面向对象的语言，都支持封装、继承和多态
Java 不提供指针来直接访问内存，有自动内存管理机制
Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。

**6.** **什么是** **Java** **程序的主类 应用程序和小程序的主类有何不同**

一个程序中可以有多个类，但只能有一个类是主类,。
在 Java 应用程序中，这个主类是指包含 main（）方法的类,应用程序的主类不一定要求是 public类。
在 Java 小程序中，这个主类是一个继承自系统类 JApplet 或 Applet 的子类,小程序的主类要求必须是 public 类。

**7. Java** **应用程序与小程序之间有那些差别**

applet 小程序没有main 方法，主要是嵌在浏览器页面上运行(调用 init()线程或者 run()来启动)，嵌入浏览器这点跟 flash 的小游戏类似。

**8.** **字符型常量和字符串常量的区别**
1. 形式上: 字符常量是单引号引起的一个字符 字符串常量是双引号引起的若干个字符
2. 含义上: 字符常量相当于一个整形值( ASCII 值),可以参加表达式运算 字符串常量代表一个地址值(该字符串在内存中存放位置)
3. 占内存大小 字符常量只占 2 个字节 字符串常量占若干个字节(至少一个字符结束标志) 

**9.** **构造器** **Constructor** **是否可被** **override**

父类的私有属性和构造方法并不能被继承，所以Constructor 也就不能被 override（重写）,但是可以 overload（重载）


**10.** **重载和重写的区别**
**重载：** 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。 　　
**重写：** 发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为 private 则子类就不能重写该方法。

**11. Java** **面向对象编程三大特性****:** **封装 继承 多态**
**封装**封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法
**继承**继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能。
**多态**一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。

**12. String StringBuffer** **和** **StringBuilder** **的区别****是什么** **String** **为什么是不可变的**
String 类中使用 final 关键字字符数组保存字符串，所以String 对象是不可变的。
StringBuilder 与StringBuffer 都继承自 AbstractStringBuilder 类

String 中的对象是不可变的，也就可以理解为常量，线程安全。
StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。
StringBuilder 并没有对方法进行加同步锁，所以是非线程安全

每次对 String 类型进行改变的时候，都会生成一个新的 String 对象
StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，

**13.** **自动装箱与拆箱**
**装箱**：将基本类型用它们对应的引用类型包装起来；
**拆箱**：将包装类型转换为基本数据类型；
**14.** **在一个静态方法内调用一个非静态成员为什么是****非法的**
由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。

**15.** **在** **Java** **中定义一个不做事且没有参数的构造**

Java 程序在执行子类的构造方法之前，如果没有用 super() 来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。

**16. import java** **和** **javax** **有什么区别**

刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是扩展API 包来说使用。

**17.** **接口和抽象类的区别是什么**

1. 接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），抽象类可以有非抽象的方法

2. 接口中的实例变量默认是 final 类型的，而抽象类中则不一定

3. 一个类可以实现多个接口，但最多只能实现一个抽象类

4. 一个类实现接口的话要实现接口的所有方法，而抽象类不一定

5. 接口不能用 new 实例化，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。

**18.** **成员变量与局部变量的区别有那些**

1. 成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；
2. 成员变量是对象的一部分，而对象存在于堆内存，局部变量存在于栈内存 
3. 成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。
4. 成员变量如果没有被赋初值，则会自动以类型的默认值而赋值；而局部变量则不会自动赋值。

**19.** **创建一个对象用什么运算符****?****对象实体与对象引****用有何不同****?**
new 运算符，new 创建对象实例（,对象实例在堆内存中）

**20.** **什么是方法的返回值****?****返回值在类的方法里的作****用是什么****?**

方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！
返回值的作用:接收出结果，使得它可以用于其他的操作！

**21.** **一个类的构造方法的作用是什么 若一个类没有****声明构造方法****,****该程序能正确执行吗** **?****为什么****?**

 主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。

 **22.** **构造方法有哪些特性**
1. 名字与类名相同；2. 没有返回值，但不能用 void 声明构造函数；3. 生成类的对象时自动执行，无需调用。

**23.** **静态方法和实例方法有何不同**
1. 在外部调用静态方法时，可以使用"类名.方法名"的方式，也可以使用"对象名.方法名"的方式。
2. 静态方法在访问本类的成员时，只允许访问静态成员
**24.** **对象的相等与指向他们的引用相等，两者有什么****不同？**

 对象的相等，比的是内存中存放的内容是否相等。
 引用相等，比较的是他们指向的内存地址是否相等。

 **25.** **在调用子类构造方法之前会先调用父类没有参数****的构造方法，其目的是****?**帮助子类做初始化工作。

**26. ==** **与** **equals(重要)**

 **==** : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同

一个对象。(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)

 **equals()** : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：


情况 1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。

情况 2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；

object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。

**27. hashCode** **与** **equals****（重要）**

hashCode() 的作用是是确定该对象在哈希表中的索引位置。
**hashCode****（）与** **equals****（）的相关规定**
1. 如果两个对象相等，则 hashcode 一定也是相同的
2. 两个对象相等,对两个对象分别调用 equals 方法都返回 true
3. 两个对象有相同的 hashcode 值，它们也不一定是相等的
4. **因此，****equals** **方法被覆盖过，则** **hashCode** **方法也必须被覆盖**
5. hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该 class 的两个对象无论如何都不会相等

**28.** **为什么** **Java** **中只有值传递**

是把实际参数的引用的地址**复制**了一份，传递给了形式参数

**值传递和引用传递的区别并不是传递的内容。而是实参到底有没有被复制一份给形参**

值传递（pass by value）是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。

引用传递（pass by reference）是指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。


**29.** **简述线程，程序、进程的基本概念。以及他们之****间关系是什么**
**线程**与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。线程也被称为轻量级进程。
**程序**是含有指令和数据的文件，是静态的代码。
**进程**是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。
**30.** **线程有哪些基本状态****?**Java 线程只可能处于下面 6 种不同状态的其中一个状态。

**31** **关于** **final** **关键字的一些总结**final 关键字主要用在三个地方：变量、方法、类。

**32 Java** **中的异常处理**
**Error****（错误）****:****是程序无法处理的错误**
**Exception****（异常）****:****是程序本身可以处理的异常**。

**在以下** **4** **种特殊情况下，****finally** **块不会被执行：**

1. 在 finally 语句块中发生了异常。2. 在前面的代码中用了 System.exit()退出程序。3. 程序所在的线程死亡。4. 关闭 CPU。

**33 Java** **序列化中如果有些字段不想进行序列化 怎****么办**
对于不想进行序列化的变量，使用 transient 关键字修饰。transient 只能修饰变量，不能修饰类和方法。
**34** **获取用键盘输入常用的的两种方法**
方法 1：通过 Scanner方法 2：通过 BufferedReader