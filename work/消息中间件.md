## ActiveMQ
**1.什么是 ActiveMQ?** activeMQ 是一种开源的，实现了 JMS1.1 规范的，面向消息(MOM)的中间件

 **2. ActiveMQ 服务器宕机怎么办？**

非持久化消息是存储在内存中的，持久化消息是存储在文件中的。在非持久化消息堆积到一定程度，内存告急的时候，ActiveMQ 会将内存中的非持久化消息写入临时文件中，以腾出内存。当达到临时文件最大限制时候，消费会停止。

**解决方案**：尽量不要用非持久化消息，非要用的话，将临时文件限制尽可能的调大。

 **3. 丢消息怎么办？**

发送方发送一堆数据，然后调用 close 关闭连接之后。当接收者尝试发送数据时，由于此时连接已关闭，所以会

发生异常。

**解决方案**：用持久化消息，或者非持久化消息及时处理不要堆积，或者启动事务，启动事务后，commit()

方法会负责任的等待服务器的返回，也就不会关闭连接导致消息丢失了。

**4. 持久化消息非常慢。**

非持久化的消息是异步发送的，持久化的消息是同步发送的

在开启事务的情况下，消息都是异步发送的，效率会有 2 个数量级的提升。

**5. 消息的不均匀消费。**

原因在于 ActiveMQ 的 prefetch 机制。当消费者去获取消息时而是一次性获取一批，默认是 1000 条。

解决方案：将 prefetch 设为 1，每次处理 1 条消息，处理完再去取，这样也慢不了多少。

**6. 死信队列。**

如果你想在消息处理失败后，不被服务器删除，还能被其他消费者处理或重试，可以关闭

AUTO_ACKNOWLEDGE，将 ack 交由程序自己处理。

一种是调用 consumer.receive()方法，该方法将阻塞直到获得并返回一条消息。

另一种方法是采用 listener 回调函数，在有消息到达时，会调用 listener 接口的 onMessage 方法。

**7. ActiveMQ 中的消息重发时间间隔和重发次数吗？**

**解决方案**

