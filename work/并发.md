**1.Synchronized 用过吗，其原理是什么？**

被Synchronized修饰过的程序块，在编译前后被编译器生成了monitorenter和monitorexit两个字节码指令。
在JVM执行到monitorenter指令时，首先要尝试获取对象的锁：
如果得到了把锁的计数器+1；当执行monitorexit指令时将锁计数器-1；当计数器为0时，锁就被释放了。
Synchronize通过在对象头设置标记，达到了获取锁和释放锁的目的。

**2：你刚才提到获取对象的锁，这个“锁”到底是什么？如何确定对象的锁？**
“锁”的本质其实是1个参数，即要锁定和解锁的对象。

1.如果Synchronized明确指定了锁对象，说明加解锁对象为该对象。
2.Synchronized修饰的方法为非静态方法，表示此方法对应的对象为锁对象；
3.若Synchronized修饰的方法为静态方法，则表示此方法对应的类对象为锁对象。

**3：什么是可重入性，为什么说Synchronized是可重入锁？**
可重入性是锁的1个基本要求，是为了解决自己锁死自己的情况。
1个类中的同步方法调用另1个同步方法，导致自己锁死自己。

**4：JVM 对 Java 的原生锁做了哪些优化？**



**问题五：为什么说 Synchronized 是非公平锁？**



**问题六：什么是锁消除和锁粗化？**



**问题七：为什么说 Synchronized 是一个悲观锁？乐观锁的实现原理又是什么？什么是 CAS，它有什么特性？**





**问题八：乐观锁一定就是好的吗？**



**可重入锁 ReentrantLock 及其他显式锁相关问题**
**问题一：跟 Synchronized 相比，可重入锁 ReentrantLock 其实现原理有什么不同？**





**问题二：那么请谈谈 AQS 框架是怎么回事儿？**





**问题三：请尽可能详尽地对比下 Synchronized 和 ReentrantLock 的异同。**





**问题四：ReentrantLock 是如何实现可重入性的？**



**问题五：除了 ReetrantLock，你还接触过 JUC 中的哪些并发工具？**



**问题六：请谈谈 ReadWriteLock 和 StampedLock。**



**问题七：如何让 Java 的线程彼此同步？你了解过哪些同步器？请分别介绍下。**



**问题八：CyclicBarrier 和 CountDownLatch 看起来很相似，请对比下呢？**



Java 线程池相关问题
问题一：Java 中的线程池是如何实现的？



问题二：创建线程池的几个核心构造参数？



问题三：线程池中的线程是怎么创建的？是一开始就随着线程池的启动创建好的吗？



问题四：既然提到可以通过配置不同参数创建出不同的线程池，那么 Java 中默认实现好的线程池又有哪些呢？请比较它们的异同。



问题六：如何在 Java 线程池中提交线程？



Java 内存模型相关问题
问题一：什么是 Java 的内存模型，Java 中各个线程是怎么彼此看到对方的变量的？



问题二：请谈谈 volatile 有什么特点，为什么它能保证变量对所有线程的可见性？



问题三：既然 volatile 能够保证线程间的变量可见性，是不是就意味着基于 volatile 变量的运算就是并发安全的？



问题四：请对比下 volatile 对比 Synchronized 的异同。



问题五：请谈谈 ThreadLocal 是怎么解决并发安全的？



问题六：很多人都说要慎用 ThreadLocal，谈谈你的理解，使用 ThreadLocal 需要注意些什么？





------------

## 多线程

**1)现在有 T1、T2、T3 三个线程顺序执行？**
Join把指定的线程加入到当前线程，把两个交替执行合并为顺序执行。

**2)在 Java 中 Lock 接口比 synchronized 块的优势是什么？**
lock 接口为读和写分别提供了锁，它能满足有条件的阻塞。

**3)在 java 中 wait 和 sleep 方法的不同？**
 wait 会释放锁，而 sleep 一直持有锁。
 Wait 用于线程间交互，sleep 用于暂停执行。

**4）用 Java 实现阻塞队列。**
如果他用 wait()和 notify()方法来实现阻塞队列

**5）用 Java 写代码来解决生产者——消费者问题。**

==**6）用 Java 编程一个会导致死锁的程序，你将怎么解决？**==

**死锁：线程A和线程B相互等待对方持有的锁，导致程序无限死循环下去**

避免死锁的方式：
1、让程序每次至多只能获得一个锁。
2、减少嵌在的加锁交互数量。
3、设置线程等待时间的上限

**7) 什么是原子操作，Java 中的原子操作是什么？**

**8) Java 中的 volatile 关键是什么作用？怎样使用它？在 Java 中它跟 synchronized 方法有什么不同？**
volatile 变量怎样在并发环境中确保可见性。

**9) 什么是竞争条件？你怎样发现和解决竞争？**

**10) 你将如何使用 threaddump？你将如何分析 Thread dump？**

**11) 为什么我们调用 start()方法时会执行 run()方法，为什么我们不能直接调用 run()方法？**
调用 start()方法时你将创建新的线程，并执行在 run()方法里的代码。
直接调用 run()方法，它不会创建新的线程也不会执行调用线程的代码。

**12) Java 中你怎样唤醒一个阻塞的线程？**
如果线程因为调用 wait()、sleep()、或者 join()方法而
导致的阻塞，你可以中断线程，并且通过抛出 InterruptedException 来唤醒它。

**13)在 Java 中 CycliBarriar 和 CountdownLatch 有什么区别？**
CyclicBarrier 可以重复使用已经通过的障碍，
CountdownLatch 不能重复使用。

**14) 什么是不可变对象，它对写并发应用有什么帮助？**

**15) 你在多线程环境中遇到的常见的问题是什么？你是怎么解决它的？**
竞争条件、死锁、活锁和饥饿。

-----



**多线程的使用场景**

excel文件导入,读取excel文件中的数据，数据量大概有20W左右。然后把这些数据调用10个线程，把数据insert到数据库中。

-----

**多线程同步的场景**

线程同步有三种方式

countdownlatch cyclebarrier smphore

---

线程通信：1.是通过共享变量2.通过队列

 wait()线程等待,notify()线程唤醒

先启动了Consumer线程，但是，由于仓库中没有产品，因此，Consumer线程就会调用wait()方法进入等待队列进行等待，直到Producer线程将产品生产出来并放进仓库，然后使用notify()方法将其唤醒

-----

锁的分类：

根据线程是否需要锁住资源，分为乐观锁 悲观锁

根据多个线程竞争是否需要排队：分为公平锁与非公平锁

根据多个线程是否可以共享一个锁：分为共享锁与排它锁

根据一个线程的多个流程是否可以获取同一把锁，分为可重入锁与不可重入锁

------

**线程池面试题**

## 为什么要使用线程池？

创建线程和销毁线程的花销是比较大的

## 线程池有什么作用？

1、提高效率2、方便管理

----

## 说说几种常见的线程池及使用场景

单线程线程池，定长线程池，可缓存线程池，定长线程池

## 怎么理解无界队列和有界队列

**有界队列**
 1.初始的poolSize < corePoolSize，提交的runnable任务，会直接做为new一个Thread的参数，立马执行 。
 2.当提交的任务数超过了corePoolSize，会将当前的runable提交到一个block queue中。
 3.有界队列满了之后，如果poolSize < maximumPoolsize时，会尝试new 一个Thread的进行救急处理，立马执行对应的runnable任务。
 4.如果3中也无法处理了，就会走到第四步执行reject操作。
 **无界队列**
 与有界队列相比，除非系统资源耗尽，否则无界的任务队列不存在任务入队失败的情况。当有新的任务到来，系统的线程数小于corePoolSize时，则新建线程执行任务。当达到corePoolSize后，就不会继续增加，若后续仍有新的任务加入，而没有空闲的线程资源，则任务直接进入队列等待。若任务创建和处理的速度差异很大，无界队列会保持快速增长，直到耗尽系统内存。

当线程池的任务缓存队列已满并且线程池中的线程数目达到maximumPoolSize，如果还有任务到来就会采取任务拒绝策略。

----

线程安全是指多个线程在执行同一段代码的时候采用加锁机制，使每次的执行结果和单线程执行的结果都是一样的。
线程不安全就是不提供加锁机制保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据。

==非线程安全是指多线程操作同一个对象可能会出现问题。==

同步方法 同步代码块 轻量级的Lock接口

多个线程访问一个对象的实例变量，会出现线程安全问题

-----

ArrayList是非线程安全的，Vector是线程安全的；

HashMap是非线程安全的，HashTable是线程安全的；

StringBuilder是非线程安全的，StringBuffer是线程安全的。

**什么是线程安全？线程安全和非线程安全有什么区别？分别在什么情况下使用？**

