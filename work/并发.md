**1.Synchronized 用过吗，其原理是什么？**

被Synchronized修饰过的程序块，在编译前后被编译器生成了monitorenter和monitorexit两个字节码指令。
在JVM执行到monitorenter指令时，首先要尝试获取对象的锁：
如果得到了把锁的计数器+1；当执行monitorexit指令时将锁计数器-1；当计数器为0时，锁就被释放了。
Synchronize通过在对象头设置标记，达到了获取锁和释放锁的目的。

**2：你刚才提到获取对象的锁，这个“锁”到底是什么？如何确定对象的锁？**
“锁”的本质其实是字节码指令的1个Reference类型的参数，即要锁定和解锁的对象。

1.如果Synchronized明确指定了锁对象，说明加解锁对象为该对象。
2.Synchronized修饰的方法为非静态方法，表示此方法对应的对象为锁对象；
3.若Synchronized修饰的方法为静态方法，则表示此方法对应的类对象为锁对象。

**3：什么是可重入性，为什么说Synchronized是可重入锁？**
可重入性是锁的1个基本要求，是为了解决自己锁死自己的情况。
1个类中的同步方法调用另1个同步方法，导致自己锁死自己。

**4：JVM 对 Java 的原生锁做了哪些优化？**







------------

## 多线程

**1)现在有 T1、T2、T3 三个线程顺序执行？**
Join把指定的线程加入到当前线程，把两个交替执行合并为顺序执行。

**2)在 Java 中 Lock 接口比 synchronized 块的优势是什么？**
lock 接口为读和写分别提供了锁，它能满足有条件的阻塞。

**3)在 java 中 wait 和 sleep 方法的不同？**
 wait 会释放锁，而 sleep 一直持有锁。
 Wait 用于线程间交互，sleep 用于暂停执行。

**4）用 Java 实现阻塞队列。**
如果他用 wait()和 notify()方法来实现阻塞队列

**5）用 Java 写代码来解决生产者——消费者问题。**

**6）用 Java 编程一个会导致死锁的程序，你将怎么解决？**

**7) 什么是原子操作，Java 中的原子操作是什么？**

**8) Java 中的 volatile 关键是什么作用？怎样使用它？在 Java 中它跟 synchronized 方法有什么不同？**
volatile 变量怎样在并发环境中确保可见性。

**9) 什么是竞争条件？你怎样发现和解决竞争？**

**10) 你将如何使用 threaddump？你将如何分析 Thread dump？**

**11) 为什么我们调用 start()方法时会执行 run()方法，为什么我们不能直接调用 run()方法？**
调用 start()方法时你将创建新的线程，并执行在 run()方法里的代码。
直接调用 run()方法，它不会创建新的线程也不会执行调用线程的代码。

**12) Java 中你怎样唤醒一个阻塞的线程？**
如果线程因为调用 wait()、sleep()、或者 join()方法而
导致的阻塞，你可以中断线程，并且通过抛出 InterruptedException 来唤醒它。

**13)在 Java 中 CycliBarriar 和 CountdownLatch 有什么区别？**
CyclicBarrier 可以重复使用已经通过的障碍，
CountdownLatch 不能重复使用。

**14) 什么是不可变对象，它对写并发应用有什么帮助？**

**15) 你在多线程环境中遇到的常见的问题是什么？你是怎么解决它的？**
竞争条件、死锁、活锁和饥饿。

-----

